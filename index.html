<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Infinite Generative Engine</title>
  <style>
    :root{
      --fg: rgba(255,255,255,.82);
      --fg2: rgba(255,255,255,.62);
    }
    html,body{height:100%;margin:0;overflow:hidden;background:#03040a;}
    canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block;}
    .ui{
      position:fixed;inset:auto 16px 16px 16px;
      display:flex;gap:12px;align-items:center;justify-content:space-between;
      pointer-events:none;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .panel{
      pointer-events:auto;
      display:flex;gap:10px;align-items:center;
      padding:10px 12px;border-radius:16px;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
    }
    button{
      cursor:pointer;
      border: 1px solid rgba(255,255,255,.16);
      background: radial-gradient(120% 140% at 20% 20%, rgba(255,255,255,.18), rgba(255,255,255,.06));
      color: var(--fg);
      padding:10px 14px;border-radius:14px;
      font-weight:700; letter-spacing:.6px;
      transition: transform .12s ease, filter .12s ease;
    }
    button:hover{ transform: translateY(-1px); filter: brightness(1.08); }
    button:active{ transform: translateY(0px) scale(.99); }
    .meta{color:var(--fg2);font-size:12px;line-height:1.25}
    .meta b{color:var(--fg)}
    .hint{opacity:.75}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="ui">
    <div class="panel">
      <button id="gen">GENERATE</button>
      <div class="meta">
        <div><b>Seed:</b> <span id="seed">—</span></div>
        <div class="hint">Click → new universe • Drag → force • Space → burst • R → reset</div>
      </div>
    </div>
    <div class="panel meta">
      <div><b>Mode:</b> <span id="mode">—</span></div>
    </div>
  </div>

<script>
/* =========================================================
   “Infinite Generative Engine”
   - single file, no libs
   - click creates a new deterministic universe (seed)
   - each universe evolves forever
   ========================================================= */

// ---------- Canvas ----------
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: true });

let W=0,H=0,DPR=Math.min(2, devicePixelRatio||1);
function resize(){
  W = innerWidth|0; H = innerHeight|0;
  canvas.width = (W*DPR)|0; canvas.height = (H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener("resize", resize, {passive:true});
resize();

// ---------- UI ----------
const $seed = document.getElementById("seed");
const $mode = document.getElementById("mode");
const $gen  = document.getElementById("gen");

// ---------- Deterministic PRNG (seeded) ----------
function sfc32(a,b,c,d){
  return function(){
    a|=0; b|=0; c|=0; d|=0;
    let t = (a + b | 0) + d | 0;
    d = d + 1 | 0;
    a = b ^ b >>> 9;
    b = c + (c<<3) | 0;
    c = (c<<21 | c>>>11);
    c = c + t | 0;
    return (t >>> 0) / 4294967296;
  };
}
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h<<13) | (h>>>19);
  }
  return function(){
    h = Math.imul(h ^ (h>>>16), 2246822507);
    h = Math.imul(h ^ (h>>>13), 3266489909);
    return (h ^= h>>>16) >>> 0;
  };
}
function makeRng(seedStr){
  const h = xmur3(seedStr);
  return sfc32(h(), h(), h(), h());
}

// ---------- Pointer ----------
const pointer = {x:W*0.5, y:H*0.5, down:false};
addEventListener("pointerdown", e=>{pointer.down=true; pointer.x=e.clientX; pointer.y=e.clientY;},{passive:true});
addEventListener("pointerup",   ()=>{pointer.down=false;},{passive:true});
addEventListener("pointermove", e=>{pointer.x=e.clientX; pointer.y=e.clientY;},{passive:true});

// ---------- Universe State ----------
let rng = makeRng("boot");
let universe = null;
let t = 0;
let clickCount = 0;

// ---------- Helpers ----------
const TAU = Math.PI * 2;
function clamp(x,a,b){ return x<a?a:(x>b?b:x); }
function lerp(a,b,t){ return a + (b-a)*t; }
function hashColorHue(rand){
  // stable “signature” hue per universe
  return Math.floor(rand()*360);
}

// ---------- Scene 1: Flow Field Neon Trails ----------
function makeFlowField(rand){
  const n = (6000 + Math.floor(rand()*9000));     // particles
  const trailAlpha = lerp(0.035, 0.10, rand());   // persistence
  const speed = lerp(0.55, 1.10, rand());
  const noiseScale = lerp(0.0012, 0.0045, rand());
  const curl = lerp(1.2, 2.8, rand());
  const hue0 = hashColorHue(rand);
  const hueDrift = lerp(10, 85, rand);
  const forceRadius = lerp(140, 320, rand());
  const forceStrength = lerp(1.2, 4.0, rand());

  const P = new Float32Array(n*4);
  for (let i=0;i<n;i++){
    const k=i*4;
    P[k]=rand()*W; P[k+1]=rand()*H;
    P[k+2]=(rand()-.5)*0.2; P[k+3]=(rand()-.5)*0.2;
  }

  let phase = rand()*1000;

  function fieldAngle(x,y){
    const ax = x*noiseScale, ay=y*noiseScale;
    // layered trig “fake noise”
    const a = Math.sin(ax + phase) + 0.6*Math.cos(ay*1.3 - phase*0.9) + 0.35*Math.sin((ax+ay)*0.7 + phase*0.4);
    const b = Math.cos(ay - phase) + 0.6*Math.sin(ax*1.2 + phase*1.1) - 0.35*Math.cos((ax-ay)*0.8 - phase*0.5);
    return Math.atan2(b,a)*curl;
  }

  function burst(){
    const cx=pointer.x, cy=pointer.y;
    for (let i=0;i<n;i+=2){
      const k=i*4;
      const dx=P[k]-cx, dy=P[k+1]-cy;
      const d=Math.hypot(dx,dy)+0.001;
      const f=(280 + rand()*420)/d;
      P[k+2] += (dx/d)*f;
      P[k+3] += (dy/d)*f;
    }
  }

  return {
    name:"Neon Flow Field",
    clear(){
      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle="rgba(0,0,0,1)";
      ctx.fillRect(0,0,W,H);
    },
    burst,
    step(dt){
      phase += Math.PI * 0.0025 * dt;

      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle = `rgba(0,0,0,${trailAlpha})`;
      ctx.fillRect(0,0,W,H);

      ctx.globalCompositeOperation="lighter";
      ctx.lineWidth = lerp(0.7, 1.8, rand());

      const fx=pointer.x, fy=pointer.y;
      const R=forceRadius, R2=R*R;

      for (let i=0;i<n;i++){
        const k=i*4;
        const x=P[k], y=P[k+1];
        let vx=P[k+2], vy=P[k+3];

        const ang = fieldAngle(x,y);
        vx += Math.cos(ang)*0.18;
        vy += Math.sin(ang)*0.18;

        const dx=fx-x, dy=fy-y;
        const d2=dx*dx+dy*dy;
        if (d2 < R2){
          const d=Math.sqrt(d2)+0.001;
          const pull=(1 - d/R);
          const s=(pointer.down?1:-0.22)*forceStrength*pull;
          vx += (dx/d)*s;
          vy += (dy/d)*s;
        }

        vx *= 0.92; vy *= 0.92;
        const nx = x + vx*speed;
        const ny = y + vy*speed;

        const hue = (hue0 + (ang*180/Math.PI) + (t*hueDrift))%360;
        ctx.strokeStyle = `hsla(${hue}, 95%, 62%, 0.55)`;
        ctx.beginPath();
        ctx.moveTo(x,y);
        ctx.lineTo(nx,ny);
        ctx.stroke();

        // wrap
        let wx=nx, wy=ny;
        if (wx<0) wx+=W; else if (wx>W) wx-=W;
        if (wy<0) wy+=H; else if (wy>H) wy-=H;

        P[k]=wx; P[k+1]=wy; P[k+2]=vx; P[k+3]=vy;
      }

      ctx.globalCompositeOperation="source-over";
    }
  };
}

// ---------- Scene 2: Nebula “Fractal-ish” ----------
function makeNebula(rand){
  const hue0 = hashColorHue(rand);
  const layers = 5 + (rand()*6|0);
  const grain = lerp(0.02, 0.07, rand());
  const fade = lerp(0.04, 0.12, rand());
  const swirl = lerp(0.6, 2.2, rand());
  let phase = rand()*1000;

  function burst(){ phase += Math.PI * (2 + rand()*6); }

  return {
    name:"Nebula Bloom",
    clear(){
      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle="rgba(0,0,0,1)";
      ctx.fillRect(0,0,W,H);
    },
    burst,
    step(dt){
      phase += Math.PI*0.0009*dt;

      // gentle fade
      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle = `rgba(0,0,0,${fade})`;
      ctx.fillRect(0,0,W,H);

      ctx.globalCompositeOperation="lighter";

      const cx = pointer.down ? pointer.x : W*0.5;
      const cy = pointer.down ? pointer.y : H*0.5;

      for (let L=0; L<layers; L++){
        const s = 0.35 + L*0.18;
        const rad = Math.min(W,H) * (0.18 + L*0.06);
        const a = phase*(1 + L*0.12) + t*(0.5 + L*0.09);

        const x = cx + Math.cos(a*swirl) * rad * (0.7 + 0.25*Math.sin(a*1.3));
        const y = cy + Math.sin(a*swirl) * rad * (0.7 + 0.25*Math.cos(a*1.1));

        const hue = (hue0 + L*22 + t*18)%360;
        const alpha = 0.07 + 0.02*L;

        ctx.beginPath();
        ctx.fillStyle = `hsla(${hue}, 90%, ${55 + L*3}%, ${alpha})`;
        ctx.arc(x, y, rad*s, 0, TAU);
        ctx.fill();
      }

      // subtle “grain”
      ctx.globalCompositeOperation="overlay";
      ctx.fillStyle = `rgba(255,255,255,${grain})`;
      for(let i=0;i<120;i++){
        const x=rand()*W, y=rand()*H;
        ctx.fillRect(x,y,1,1);
      }

      ctx.globalCompositeOperation="source-over";
    }
  };
}

// ---------- Scene 3: Moiré / Interference ----------
function makeMoire(rand){
  const hue0 = hashColorHue(rand);
  const fade = lerp(0.06, 0.16, rand());
  const density = 280 + (rand()*520|0);
  const amp = lerp(8, 42, rand());
  const freq = lerp(0.6, 2.6, rand());
  let phase = rand()*1000;

  function burst(){ phase += Math.PI * 10; }

  return {
    name:"Moiré Interference",
    clear(){
      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle="rgba(0,0,0,1)";
      ctx.fillRect(0,0,W,H);
    },
    burst,
    step(dt){
      phase += Math.PI*0.0016*dt;

      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle = `rgba(0,0,0,${fade})`;
      ctx.fillRect(0,0,W,H);

      ctx.globalCompositeOperation="lighter";
      ctx.lineWidth = 1;

      const cx = pointer.x, cy = pointer.y;
      const base = (t*35 + hue0)%360;

      for(let i=0;i<density;i++){
        const u = i/density;
        const x = u*W;
        const y = H*0.5 + Math.sin((u*TAU*freq) + phase) * amp
                        + Math.sin((u*TAU*(freq*1.7)) - phase*0.7) * (amp*0.45);

        const dx = x - cx, dy = y - cy;
        const d = Math.hypot(dx,dy)+1;
        const twist = Math.sin(d*0.02 + phase*0.4) * 16;

        const hue = (base + twist + u*120)%360;
        ctx.strokeStyle = `hsla(${hue}, 90%, 60%, 0.28)`;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + 18 + 18*Math.sin(phase + u*12));
        ctx.stroke();
      }

      ctx.globalCompositeOperation="source-over";
    }
  };
}

// ---------- Scene 4: Orbital Ribbons ----------
function makeRibbons(rand){
  const hue0 = hashColorHue(rand);
  const fade = lerp(0.03, 0.10, rand());
  const ribbons = 9 + (rand()*18|0);
  const width = lerp(0.8, 2.8, rand());
  const speed = lerp(0.5, 1.6, rand());
  const wobble = lerp(0.6, 2.3, rand());
  let phase = rand()*1000;

  function burst(){ phase += Math.PI * 5; }

  return {
    name:"Orbital Ribbons",
    clear(){
      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle="rgba(0,0,0,1)";
      ctx.fillRect(0,0,W,H);
    },
    burst,
    step(dt){
      phase += Math.PI*0.0018*dt;

      ctx.globalCompositeOperation="source-over";
      ctx.fillStyle = `rgba(0,0,0,${fade})`;
      ctx.fillRect(0,0,W,H);

      ctx.globalCompositeOperation="lighter";
      ctx.lineWidth = width;

      const cx = pointer.down ? pointer.x : W*0.5;
      const cy = pointer.down ? pointer.y : H*0.5;

      for(let r=0;r<ribbons;r++){
        const k = r/(ribbons-1);
        const rad = (Math.min(W,H)*0.12) + k*Math.min(W,H)*0.38;
        const a0 = phase*(1+k*0.6) + t*(speed + k*0.9);

        const hue = (hue0 + k*160 + t*22)%360;
        ctx.strokeStyle = `hsla(${hue}, 95%, 62%, ${0.10 + k*0.16})`;

        ctx.beginPath();
        for(let i=0;i<260;i++){
          const u=i/259;
          const a = a0 + u*TAU*(0.6 + k*0.7);
          const w = 1 + 0.25*Math.sin(a*wobble + k*7);
          const x = cx + Math.cos(a)*rad*w + Math.cos(a*2.1+phase)*rad*0.06;
          const y = cy + Math.sin(a)*rad*w + Math.sin(a*1.9-phase)*rad*0.06;
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      ctx.globalCompositeOperation="source-over";
    }
  };
}

// ---------- Universe generator ----------
function newUniverse(){
  clickCount++;

  // “asla aynı olmasın” diye: time + click + entropy
  const seedStr = [
    "u",
    Date.now().toString(36),
    performance.now().toFixed(3),
    clickCount.toString(36),
    (Math.random()*1e9|0).toString(36)
  ].join("-");

  rng = makeRng(seedStr);
  $seed.textContent = seedStr;

  // Choose and blend: seeded selection
  const pick = rng();
  const sceneA = pick < 0.30 ? makeFlowField(rng)
               : pick < 0.55 ? makeNebula(rng)
               : pick < 0.78 ? makeMoire(rng)
               : makeRibbons(rng);

  // A “secondary” scene occasionally layered subtly
  const pick2 = rng();
  const sceneB = pick2 < 0.25 ? makeNebula(rng)
               : pick2 < 0.50 ? makeRibbons(rng)
               : pick2 < 0.75 ? makeMoire(rng)
               : makeFlowField(rng);

  const mix = rng() < 0.55; // sometimes combine
  const modeName = mix ? `${sceneA.name} + ${sceneB.name}` : sceneA.name;
  $mode.textContent = modeName;

  universe = {
    name: modeName,
    burst(){
      sceneA.burst?.();
      if(mix) sceneB.burst?.();
    },
    clear(){
      sceneA.clear?.();
      if(mix){
        // don't fully clear twice; add a subtle veil
        ctx.globalCompositeOperation="source-over";
        ctx.fillStyle="rgba(0,0,0,0.35)";
        ctx.fillRect(0,0,W,H);
      }
    },
    step(dt){
      sceneA.step(dt);
      if(mix){
        // subtle second layer
        ctx.save();
        ctx.globalAlpha = 0.55;
        sceneB.step(dt);
        ctx.restore();
      }
    }
  };

  universe.clear();
}

newUniverse();

// ---------- Controls ----------
$gen.addEventListener("click", newUniverse);

addEventListener("keydown", (e)=>{
  if(e.code==="Space") universe?.burst?.();
  if(e.key.toLowerCase()==="r") universe?.clear?.();
});

// ---------- Main loop ----------
let last = performance.now();
function frame(now){
  const dt = clamp((now - last) / 16.6667, 0.25, 2.5);
  last = now;
  t += 0.013 * dt;

  // safety: if resized, keep universe stable
  // (no auto-regeneration; you control with button)
  universe?.step(dt);

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
